<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api-documentation for
    <a

        href="https://github.com/ljharb/qs"

    >qs (v6.4.0)</a>
</h1>
<h4>A querystring parser that supports nesting and arrays, with a depth limit</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.qs">module qs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.qs.parse">
            function <span class="apidocSignatureSpan">qs.</span>parse
            <span class="apidocSignatureSpan">(str, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.qs.stringify">
            function <span class="apidocSignatureSpan">qs.</span>stringify
            <span class="apidocSignatureSpan">(object, opts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">qs.</span>formats</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">qs.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.qs.utils">module qs.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.qs.utils.arrayToObject">
            function <span class="apidocSignatureSpan">qs.utils.</span>arrayToObject
            <span class="apidocSignatureSpan">(source, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.qs.utils.compact">
            function <span class="apidocSignatureSpan">qs.utils.</span>compact
            <span class="apidocSignatureSpan">(obj, references)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.qs.utils.decode">
            function <span class="apidocSignatureSpan">qs.utils.</span>decode
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.qs.utils.encode">
            function <span class="apidocSignatureSpan">qs.utils.</span>encode
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.qs.utils.isBuffer">
            function <span class="apidocSignatureSpan">qs.utils.</span>isBuffer
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.qs.utils.isRegExp">
            function <span class="apidocSignatureSpan">qs.utils.</span>isRegExp
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.qs.utils.merge">
            function <span class="apidocSignatureSpan">qs.utils.</span>merge
            <span class="apidocSignatureSpan">(target, source, options)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.qs" id="apidoc.module.qs">module qs</a></h1>


    <h2>
        <a href="#apidoc.element.qs.parse" id="apidoc.element.qs.parse">
        function <span class="apidocSignatureSpan">qs.</span>parse
        <span class="apidocSignatureSpan">(str, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (str, opts) {
    var options = opts || {};

    if (options.decoder !== null &#x26;&#x26; options.decoder !== undefined &#x26;&#x26; typeof options.decoder !== &#x27;function&#x27;) {
        throw new TypeError(&#x27;Decoder has to be a function.&#x27;);
    }

    options.delimiter = typeof options.delimiter === &#x27;string&#x27; || utils.isRegExp(options.delimiter) ? options.delimiter : defaults
.delimiter;
    options.depth = typeof options.depth === &#x27;number&#x27; ? options.depth : defaults.depth;
    options.arrayLimit = typeof options.arrayLimit === &#x27;number&#x27; ? options.arrayLimit : defaults.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder = typeof options.decoder === &#x27;function&#x27; ? options.decoder : defaults.decoder;
    options.allowDots = typeof options.allowDots === &#x27;boolean&#x27; ? options.allowDots : defaults.allowDots;
    options.plainObjects = typeof options.plainObjects === &#x27;boolean&#x27; ? options.plainObjects : defaults.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === &#x27;boolean&#x27; ? options.allowPrototypes : defaults.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === &#x27;number&#x27; ? options.parameterLimit : defaults.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === &#x27;boolean&#x27; ? options.strictNullHandling : defaults.strictNullHandling
;

    if (str === &#x27;&#x27; || str === null || typeof str === &#x27;undefined&#x27;) {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === &#x27;string&#x27; ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i &#x3c; keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## Usage

```javascript
var qs = require(&#x27;qs&#x27;);
var assert = require(&#x27;assert&#x27;);

var obj = qs.<span class="apidocCodeKeywordSpan">parse</span>(&#x27;a=c&#x27;);
assert.deepEqual(obj, { a: &#x27;c&#x27; });

var str = qs.stringify(obj);
assert.equal(str, &#x27;a=c&#x27;);
```

### Parsing Objects
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.qs.stringify" id="apidoc.element.qs.stringify">
        function <span class="apidocSignatureSpan">qs.</span>stringify
        <span class="apidocSignatureSpan">(object, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function (object, opts) {
    var obj = object;
    var options = opts || {};

    if (options.encoder !== null &#x26;&#x26; options.encoder !== undefined &#x26;&#x26; typeof options.encoder !== &#x27;function&#x27;) {
        throw new TypeError(&#x27;Encoder has to be a function.&#x27;);
    }

    var delimiter = typeof options.delimiter === &#x27;undefined&#x27; ? defaults.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === &#x27;boolean&#x27; ? options.strictNullHandling : defaults.strictNullHandling
;
    var skipNulls = typeof options.skipNulls === &#x27;boolean&#x27; ? options.skipNulls : defaults.skipNulls;
    var encode = typeof options.encode === &#x27;boolean&#x27; ? options.encode : defaults.encode;
    var encoder = typeof options.encoder === &#x27;function&#x27; ? options.encoder : defaults.encoder;
    var sort = typeof options.sort === &#x27;function&#x27; ? options.sort : null;
    var allowDots = typeof options.allowDots === &#x27;undefined&#x27; ? false : options.allowDots;
    var serializeDate = typeof options.serializeDate === &#x27;function&#x27; ? options.serializeDate : defaults.serializeDate;
    var encodeValuesOnly = typeof options.encodeValuesOnly === &#x27;boolean&#x27; ? options.encodeValuesOnly : defaults.encodeValuesOnly;
    if (typeof options.format === &#x27;undefined&#x27;) {
        options.format = formats.default;
    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
        throw new TypeError(&#x27;Unknown format option provided.&#x27;);
    }
    var formatter = formats.formatters[options.format];
    var objKeys;
    var filter;

    if (typeof options.filter === &#x27;function&#x27;) {
        filter = options.filter;
        obj = filter(&#x27;&#x27;, obj);
    } else if (Array.isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== &#x27;object&#x27; || obj === null) {
        return &#x27;&#x27;;
    }

    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
    } else if (&#x27;indices&#x27; in options) {
        arrayFormat = options.indices ? &#x27;indices&#x27; : &#x27;repeat&#x27;;
    } else {
        arrayFormat = &#x27;indices&#x27;;
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (sort) {
        objKeys.sort(sort);
    }

    for (var i = 0; i &#x3c; objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls &#x26;&#x26; obj[key] === null) {
            continue;
        }

        keys = keys.concat(stringify(
            obj[key],
            key,
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encode ? encoder : null,
            filter,
            sort,
            allowDots,
            serializeDate,
            formatter,
            encodeValuesOnly
        ));
    }

    return keys.join(delimiter);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var qs = require(&#x27;qs&#x27;);
var assert = require(&#x27;assert&#x27;);

var obj = qs.parse(&#x27;a=c&#x27;);
assert.deepEqual(obj, { a: &#x27;c&#x27; });

var str = qs.<span class="apidocCodeKeywordSpan">stringify</span>(obj);
assert.equal(str, &#x27;a=c&#x27;);
```

### Parsing Objects

[](#preventEval)
```javascript
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.qs.utils" id="apidoc.module.qs.utils">module qs.utils</a></h1>


    <h2>
        <a href="#apidoc.element.qs.utils.arrayToObject" id="apidoc.element.qs.utils.arrayToObject">
        function <span class="apidocSignatureSpan">qs.utils.</span>arrayToObject
        <span class="apidocSignatureSpan">(source, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayToObject = function (source, options) {
    var obj = options &#x26;&#x26; options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i &#x3c; source.length; ++i) {
        if (typeof source[i] !== &#x27;undefined&#x27;) {
            obj[i] = source[i];
        }
    }

    return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (typeof target !== &#x27;object&#x27;) {
    return [target].concat(source);
}

var mergeTarget = target;
if (Array.isArray(target) &#x26;&#x26; !Array.isArray(source)) {
    mergeTarget = exports.<span class="apidocCodeKeywordSpan">arrayToObject</span>(target, options);
}

if (Array.isArray(target) &#x26;&#x26; Array.isArray(source)) {
    source.forEach(function (item, i) {
        if (has.call(target, i)) {
            if (target[i] &#x26;&#x26; typeof target[i] === &#x27;object&#x27;) {
                target[i] = exports.merge(target[i], item, options);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.qs.utils.compact" id="apidoc.element.qs.utils.compact">
        function <span class="apidocSignatureSpan">qs.utils.</span>compact
        <span class="apidocSignatureSpan">(obj, references)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compact = function (obj, references) {
    if (typeof obj !== &#x27;object&#x27; || obj === null) {
        return obj;
    }

    var refs = references || [];
    var lookup = refs.indexOf(obj);
    if (lookup !== -1) {
        return refs[lookup];
    }

    refs.push(obj);

    if (Array.isArray(obj)) {
        var compacted = [];

        for (var i = 0; i &#x3c; obj.length; ++i) {
            if (obj[i] &#x26;&#x26; typeof obj[i] === &#x27;object&#x27;) {
                compacted.push(exports.compact(obj[i], refs));
            } else if (typeof obj[i] !== &#x27;undefined&#x27;) {
                compacted.push(obj[i]);
            }
        }

        return compacted;
    }

    var keys = Object.keys(obj);
    keys.forEach(function (key) {
        obj[key] = exports.compact(obj[key], refs);
    });

    return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var keys = Object.keys(tempObj);
    for (var i = 0; i &#x3c; keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.<span class="apidocCodeKeywordSpan">compact</span>(obj);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.qs.utils.decode" id="apidoc.element.qs.utils.decode">
        function <span class="apidocSignatureSpan">qs.utils.</span>decode
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function (str) {
    try {
        return decodeURIComponent(str.replace(/\+/g, &#x27; &#x27;));
    } catch (e) {
        return str;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.qs.utils.encode" id="apidoc.element.qs.utils.encode">
        function <span class="apidocSignatureSpan">qs.utils.</span>encode
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (str) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === &#x27;string&#x27; ? str : String(str);

    var out = &#x27;&#x27;;
    for (var i = 0; i &#x3c; string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D || // -
            c === 0x2E || // .
            c === 0x5F || // _
            c === 0x7E || // ~
            (c &#x3e;= 0x30 &#x26;&#x26; c &#x3c;= 0x39) || // 0-9
            (c &#x3e;= 0x41 &#x26;&#x26; c &#x3c;= 0x5A) || // a-z
            (c &#x3e;= 0x61 &#x26;&#x26; c &#x3c;= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c &#x3c; 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c &#x3c; 0x800) {
            out = out + (hexTable[0xC0 | (c &#x3e;&#x3e; 6)] + hexTable[0x80 | (c &#x26; 0x3F)]);
            continue;
        }

        if (c &#x3c; 0xD800 || c &#x3e;= 0xE000) {
            out = out + (hexTable[0xE0 | (c &#x3e;&#x3e; 12)] + hexTable[0x80 | ((c &#x3e;&#x3e; 6) &#x26; 0x3F)] + hexTable[0x80 | (c &#x26; 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c &#x26; 0x3FF) &#x3c;&#x3c; 10) | (string.charCodeAt(i) &#x26; 0x3FF));
        out += hexTable[0xF0 | (c &#x3e;&#x3e; 18)] + hexTable[0x80 | ((c &#x3e;&#x3e; 12) &#x26; 0x3F)] + hexTable[0x80 | ((c &#x3e;&#x3e; 6) &#x26; 0x3F)] + hexTable[
0x80 | (c &#x26; 0x3F)]; // eslint-disable-line max-len
    }

    return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.qs.utils.isBuffer" id="apidoc.element.qs.utils.isBuffer">
        function <span class="apidocSignatureSpan">qs.utils.</span>isBuffer
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBuffer = function (obj) {
    if (obj === null || typeof obj === &#x27;undefined&#x27;) {
        return false;
    }

    return !!(obj.constructor &#x26;&#x26; obj.constructor.isBuffer &#x26;&#x26; obj.constructor.isBuffer(obj));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (strictNullHandling) {
        return encoder &#x26;&#x26; !encodeValuesOnly ? encoder(prefix) : prefix;
    }

    obj = &#x27;&#x27;;
}

if (typeof obj === &#x27;string&#x27; || typeof obj === &#x27;number&#x27; || typeof obj === &#x27;boolean&#x27; || utils.<span
class="apidocCodeKeywordSpan">isBuffer</span>(obj)) {
    if (encoder) {
        var keyValue = encodeValuesOnly ? prefix : encoder(prefix);
        return [formatter(keyValue) + &#x27;=&#x27; + formatter(encoder(obj))];
    }
    return [formatter(prefix) + &#x27;=&#x27; + formatter(String(obj))];
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.qs.utils.isRegExp" id="apidoc.element.qs.utils.isRegExp">
        function <span class="apidocSignatureSpan">qs.utils.</span>isRegExp
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegExp = function (obj) {
    return Object.prototype.toString.call(obj) === &#x27;[object RegExp]&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
module.exports = function (str, opts) {
var options = opts || {};

if (options.decoder !== null &#x26;&#x26; options.decoder !== undefined &#x26;&#x26; typeof options.decoder !== &#x27;function&#
x27;) {
    throw new TypeError(&#x27;Decoder has to be a function.&#x27;);
}

options.delimiter = typeof options.delimiter === &#x27;string&#x27; || utils.<span class="apidocCodeKeywordSpan">isRegExp</span>(
options.delimiter) ? options.delimiter : defaults.delimiter;
options.depth = typeof options.depth === &#x27;number&#x27; ? options.depth : defaults.depth;
options.arrayLimit = typeof options.arrayLimit === &#x27;number&#x27; ? options.arrayLimit : defaults.arrayLimit;
options.parseArrays = options.parseArrays !== false;
options.decoder = typeof options.decoder === &#x27;function&#x27; ? options.decoder : defaults.decoder;
options.allowDots = typeof options.allowDots === &#x27;boolean&#x27; ? options.allowDots : defaults.allowDots;
options.plainObjects = typeof options.plainObjects === &#x27;boolean&#x27; ? options.plainObjects : defaults.plainObjects;
options.allowPrototypes = typeof options.allowPrototypes === &#x27;boolean&#x27; ? options.allowPrototypes : defaults.allowPrototypes
;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.qs.utils.merge" id="apidoc.element.qs.utils.merge">
        function <span class="apidocSignatureSpan">qs.utils.</span>merge
        <span class="apidocSignatureSpan">(target, source, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function (target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== &#x27;object&#x27;) {
        if (Array.isArray(target)) {
            target.push(source);
        } else if (typeof target === &#x27;object&#x27;) {
            if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (typeof target !== &#x27;object&#x27;) {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (Array.isArray(target) &#x26;&#x26; !Array.isArray(source)) {
        mergeTarget = exports.arrayToObject(target, options);
    }

    if (Array.isArray(target) &#x26;&#x26; Array.isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                if (target[i] &#x26;&#x26; typeof target[i] === &#x27;object&#x27;) {
                    target[i] = exports.merge(target[i], item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (Object.prototype.hasOwnProperty.call(acc, key)) {
            acc[key] = exports.merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i &#x3c; keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.<span class="apidocCodeKeywordSpan">merge</span>(obj, newObj, options);
    }

    return utils.compact(obj);
};
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
